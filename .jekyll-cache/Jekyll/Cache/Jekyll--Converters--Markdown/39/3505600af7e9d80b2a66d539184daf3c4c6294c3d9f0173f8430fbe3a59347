I"YD<div class="mermaid">
graph TD
A[RecyclerView] --&gt; B(LayoutManager)
A --&gt; C(Item Animator)
A --&gt; D(Adapter)
</div>

<h4 id="listview-相对-recyclerview-的局限">ListView 相对 RecyclerView 的局限</h4>

<ol>
  <li>只有纵向列表一种布局（RecyclerView 通过自定义 LayoutManager 还可解锁更多姿势）</li>
  <li>没有支持动画的 API</li>
  <li>接口设计不够明确，比如 RecyclerView 的 onCreateViewHolder 和 onBindViewHolder 体现在 ListView 中只有 getView。</li>
  <li>并没有强制实现 ViewHolder</li>
  <li>性能不如 RecyclerView</li>
</ol>

<h4 id="viewholder-究竟是什么">ViewHolder 究竟是什么？</h4>

<ol>
  <li>
    <p>ViewHolder 和 itemView 是什么关系？一对一，一对多，多对多？</p>

    <blockquote>
      <p>一对一</p>
    </blockquote>
  </li>
  <li>
    <p>ViewHolder 解决了什么问题？</p>

    <blockquote>
      <p>防止重复执行 findViewById，以提升效率</p>
    </blockquote>
  </li>
</ol>

<p>ViewHolder 和 <strong>复用</strong>没有必然关系，拿 ListView  来举例，即使不用 ViewHolder，只是如下代码，也已经起到了<strong>复用</strong>的效果</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">View</span> <span class="nf">getView</span><span class="o">(</span><span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="nc">View</span> <span class="n">convertView</span><span class="o">,</span> <span class="nc">VireGroup</span> <span class="n">parent</span><span class="o">){</span>
	<span class="c1">//只在 convertView 为 null时才创建，就是复用了View</span>
	<span class="k">if</span><span class="o">(</span><span class="n">convertView</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
		<span class="n">convertView</span> <span class="o">=</span> <span class="nc">LayoutInflater</span><span class="o">.</span><span class="na">from</span><span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="listview-缓存机制">ListView 缓存机制</h4>

<div class="mermaid">
graph LR
A[ListView] --&gt; B(RecycleBin)
A --&gt; C(Create View)
B --&gt; D(Active View)
D -.-&gt; B
B --&gt; E(Scrap View)
E -.-&gt; B
</div>
<ul>
  <li><strong>ActiveView</strong> 指的是当前显示区域的 Item 的缓存，为什么要缓存这些呢？是因为按照 Android   每16.6ms刷新一次，在此期间就会用到 ActiveView 的缓存。这里的数据是干净的，是不用重新绑定数据的。</li>
  <li><strong>Scrap View</strong> 指的是不在当前显示区域的 Item 缓存，表示已经滑出去了的 Item，数据是 dirty 的。</li>
  <li>ListView 缓存的对象是 View 对象</li>
</ul>

<h4 id="recyclerview缓存机制">RecyclerView缓存机制</h4>

<div class="mermaid">
graph LR
A[LayoutManager] --&gt; B(Recycler)
B --&gt; C(Scrap)
C -.-&gt; B
B --&gt; D(Cache)
D -.-&gt; B
B --&gt; E(ViewCacheExtension)
E -.-&gt; B
B --&gt; F(RecycledViewPool)
F -.-&gt; B
B --&gt; G(Create View)
G -.-&gt; B
</div>
<ul>
  <li><strong>Scrap</strong> 指的是当前显示区域内的 Item 缓存，类似于 ListView 的 ActiveView</li>
  <li><strong>Cache</strong> 指的是<strong>刚刚</strong>被移出屏幕的 Item，一般默认缓存2个，数据干净的，能直接复用。用于用户在<strong>回滑</strong>的时候提高性能。</li>
  <li><strong>ViewCacheExtension</strong>: 用户自定义的缓存策略。</li>
  <li><strong>RecycledViewPool</strong>: 类比于 ListView 的 ScrapView，这里面的数据是 dirty 的，需要重新绑定数据。</li>
  <li>RecyclerView 缓存的对象是 RecyclerView.ViewHolder 对象</li>
</ul>

<h4 id="recyclerview--的性能优化策略">RecyclerView  的性能优化策略</h4>

<ol>
  <li>
    <p>Item ClickListener 在 <code class="highlighter-rouge">onCreateViewHolder()</code>中设定，避免在<code class="highlighter-rouge">onBindViewHolder()</code>中设定。</p>
  </li>
  <li>
    <p>LinearLayoutManager.setInitialPrefetchItemCount() 初始化 RecyclerView 时候初始化 Item 个数。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">RecyclerView.setHasFixedSize()</code>如果Adapter 的数据变化不会导致 RecyclerView 的大小变化，可以使用<code class="highlighter-rouge">RecyclerView.setHasFixedSize(true)</code></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">//伪代码</span>
<span class="kt">void</span> <span class="nf">onContentsChanged</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">if</span><span class="o">(</span><span class="n">mHasFixedSize</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">layoutChildren</span><span class="o">();</span>
	<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
		<span class="n">requestLayout</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>很简单很厉害：</strong>多个 RecyclerView 共用 RecycledViewPool：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nc">RecyclerView</span><span class="o">.</span><span class="na">RecycledViewPool</span> <span class="n">recycledViewPool</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RecyclerView</span><span class="o">.</span><span class="na">RecycledViewPool</span><span class="o">();</span>
<span class="n">recyclerView1</span><span class="o">.</span><span class="na">setRecycledViewPool</span><span class="o">(</span><span class="n">recycledViewPool</span><span class="o">);</span>
<span class="n">recyclerView2</span><span class="o">.</span><span class="na">setRecycledViewPool</span><span class="o">(</span><span class="n">recycledViewPool</span><span class="o">);</span>
<span class="n">recyclerView3</span><span class="o">.</span><span class="na">setRecycledViewPool</span><span class="o">(</span><span class="n">recycledViewPool</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>DiffUtil：</strong>适用于整个页面需要更新，但是有部分数据是相同的。</p>

    <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="c1">// Step1: 非必须，只有当Item内部有属性更新的时候需要重写</span>
<span class="c1">// Adapter中重写 onBindViewHolder(holder: Any, position: Int, payloads: MutableList&lt;Any&gt;)方法</span>
<span class="kd">class</span> <span class="nc">Adapter</span><span class="p">()</span> <span class="p">:</span> <span class="nc">RecyclerView</span><span class="p">.</span><span class="nc">Adapter</span><span class="p">&lt;</span><span class="nc">Any</span><span class="p">&gt;()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreateViewHolder</span><span class="p">(</span><span class="n">p0</span><span class="p">:</span> <span class="nc">ViewGroup</span><span class="p">,</span> <span class="n">p1</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">Any</span> <span class="p">{}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getItemCount</span><span class="p">():</span> <span class="nc">Int</span> <span class="p">{}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onBindViewHolder</span><span class="p">(</span><span class="n">p0</span><span class="p">:</span> <span class="nc">Any</span><span class="p">,</span> <span class="n">p1</span><span class="p">:</span> <span class="nc">Int</span><span class="p">)</span> <span class="p">{}</span>
   
    <span class="c1">//当Item内部有变化的时候，调用这个方法</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onBindViewHolder</span><span class="p">(</span><span class="n">holder</span><span class="p">:</span> <span class="nc">Any</span><span class="p">,</span> <span class="n">position</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="n">payloads</span><span class="p">:</span> <span class="nc">MutableList</span><span class="p">&lt;</span><span class="nc">Any</span><span class="p">&gt;)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="k">null</span> <span class="p">==</span> <span class="n">payloads</span> <span class="p">||</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">())</span> <span class="nf">onBindViewHolder</span><span class="p">(</span><span class="n">holder</span><span class="p">,</span><span class="n">position</span><span class="p">)</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="c1">//解析 payloads,将数据更新到holder中去</span>
            <span class="kd">val</span> <span class="py">bundle</span> <span class="p">=</span> <span class="n">payloads</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="k">as</span> <span class="nc">Bundle</span>
            <span class="n">bundle</span><span class="p">.</span><span class="nf">keySet</span><span class="p">().</span><span class="nf">forEach</span> <span class="p">{</span><span class="n">key</span> <span class="p">-&gt;</span> 
                <span class="k">when</span><span class="p">(</span><span class="n">key</span><span class="p">){</span>
                    <span class="nc">User</span><span class="p">.</span><span class="nc">KEY_NAME</span> <span class="p">-&gt;</span> <span class="n">holder</span><span class="p">.</span><span class="n">name</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">bundle</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
   
<span class="c1">//Step2: 定义 DiffUtil.Callback</span>
<span class="kd">class</span> <span class="nc">CustomDiffCallback</span><span class="p">()</span> <span class="p">:</span> <span class="nc">DiffUtil</span><span class="p">.</span><span class="nc">Callback</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">areItemsTheSame</span><span class="p">(</span><span class="n">p0</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="n">p1</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">Boolean</span> <span class="p">{}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getOldListSize</span><span class="p">():</span> <span class="nc">Int</span> <span class="p">{}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getNewListSize</span><span class="p">():</span> <span class="nc">Int</span> <span class="p">{}</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">areContentsTheSame</span><span class="p">(</span><span class="n">p0</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="n">p1</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">Boolean</span> <span class="p">{}</span>
    <span class="c1">//更新这个Item的其中一部分,非必须写的方法</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">getChangePayload</span><span class="p">(</span><span class="n">oldItemPosition</span><span class="p">:</span> <span class="nc">Int</span><span class="p">,</span> <span class="n">newItemPosition</span><span class="p">:</span> <span class="nc">Int</span><span class="p">):</span> <span class="nc">Any</span><span class="p">?</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">oldUser</span> <span class="p">=</span> <span class="n">oldList</span><span class="p">[</span><span class="n">oldItemPosition</span><span class="p">]</span>
        <span class="kd">val</span> <span class="py">newUser</span> <span class="p">=</span> <span class="n">newList</span><span class="p">[</span><span class="n">newItemPosition</span><span class="p">]</span>
        <span class="kd">val</span> <span class="py">payload</span> <span class="p">=</span> <span class="nc">Bundle</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">oldUser</span><span class="p">.</span><span class="n">id</span> <span class="p">!=</span> <span class="n">newUser</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">payload</span><span class="p">.</span><span class="nf">putLong</span><span class="p">(</span><span class="nc">User</span><span class="p">.</span><span class="nc">KEY_ID</span><span class="p">,</span> <span class="n">newUser</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">oldUser</span><span class="p">.</span><span class="n">name</span> <span class="p">!=</span> <span class="n">newUser</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">payload</span><span class="p">.</span><span class="nf">putString</span><span class="p">(</span><span class="nc">User</span><span class="p">.</span><span class="nc">KEY_NAME</span><span class="p">,</span> <span class="n">newUser</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">payload</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span>
        <span class="k">return</span> <span class="n">payload</span>
    <span class="p">}</span>
<span class="p">}</span>
   
<span class="c1">//Step3: 更新 List</span>
<span class="c1">//这里的calculateDiff方法的第二个参数，true表示考虑列表数据位置变化，复杂度会变为O(n²)</span>
<span class="kd">val</span> <span class="py">diffResult</span> <span class="p">=</span> <span class="nc">DiffUtil</span><span class="p">.</span><span class="nf">calculateDiff</span><span class="p">(</span><span class="nc">CustomDiffCallback</span><span class="p">(</span><span class="n">newList</span><span class="p">,</span> <span class="n">oldList</span><span class="p">),</span> <span class="k">false</span><span class="p">)</span>
<span class="n">diffResult</span><span class="p">.</span><span class="nf">dispatchUpdatesTo</span><span class="p">(</span><span class="n">mAdapter</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <ul>
      <li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/AsyncListDiffer">AsyncListDiffer</a>: DiffUtil 后台执行方案</li>
      <li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter">RecyclerView.ListAdapter</a></li>
    </ul>
  </li>
</ol>

<h4 id="其他">其他</h4>

<ul>
  <li>onViewAttachedToWindow()：Item显示到屏幕上的时候回调。</li>
  <li>onViewDetachedFromWindow()：Item 离开屏幕时候回调，比较适合资源回收，setRecycleChildrenDetach(true) 确保页面退出的时候，调用 onViewDetachedFromWindow() 方法。</li>
  <li><a href="https://www.jianshu.com/p/f41db270d5fe">ItemDecoration深入解析与实战</a></li>
  <li>拓展：<a href="https://github.com/h6ah4i/android-advancedrecyclerview">github.com/h6ah4i/android-advancedrecyclerview</a> (RecyclerView的各种教程，Demo，拖拽，滑动等等)</li>
</ul>

<h4 id="thanks-for">Thanks for</h4>

<ol>
  <li>HenCoder Plus</li>
  <li>jiaheng</li>
</ol>

:ET