---
layout: post
title: FastDDS
subtitle: Data Distribution Service
catalog: true
use_mermaid: true
tags:
    - dds
---

# DDS

DDS（Data Distribution Service）是一套通信协议和 API 标准；它提供了以数据为中心的连接服务，基于发布者-订阅者模型。这是一套中间件，它提供介于操作系统和应用程序之间的功能，使得组件之间可以互相通信。并且提供了低延迟，高可靠的通信以及可扩展的架构。

DDS本身是一套标准。由[Object Management Group](https://www.omg.org/)（简称OMG）维护。OMG是一个开放性的非营利技术标准联盟，由许多大型IT公司组成：包括IBM，Apple Computer，Sun Microsystems等。但OMG仅仅负责制定标准，而标准的实现则由其他服务提供商完成。目前DDS的提供商有很多：[Vortex OpenSplice](https://www.adlinktech.com/en/vortex-opensplice-data-distribution-service.aspx)，[eProsima Fast RTPS](http://www.eprosima.com/)，[Hamersham](https://hamersham.com/)，[Company Summary Kongsberg Gallium](http://www.kongsberggallium.com/)，[MilSOFT](http://dds.milsoft.com.tr/en/dds-home.php)，[Object Computing OpenDDS](https://objectcomputing.com/products/opendds)，[Remedy IT](http://www.remedy.nl/)，[RTI](http://www.rti.com/)，[Twin Oaks Computing, Inc.](http://www.twinoakscomputing.com/)。

## DDS 在网络栈中的位置

![](/img/posts/dds/dds_hierarchy.png)

> 这个图之所以是沙漏形状是因为：两头的技术变化都发展很快，但是中间的却鲜有变化。

## DDS 如何降低系统复杂度

1. 传统分布式系统采用点对点的方案，会面临通道数量爆炸式增长问题：

   ![](/img/posts/dds/traditioan.png)


2. 而采用 DDS，拥有统一的 DDS DataBus，随着新节点的加入，不会增加拓扑的复杂度；

   ![](/img/posts/dds/dds_arch.png)

3. 采用基于 DDS 的上层应用，能极大简化复杂度：

   ![](/img/posts/dds/complex.png)

# FastDDS

> *eProsima Fast DDS* 目前已经被选为 [Robot Operating System 2 (ROS 2)](https://index.ros.org/doc/ros2/) 系统的默认中间件并且被包含在最新发布版本Foxy Fitzroy中。

## 特性

* 两个 API 层：包含专注**可用性的**上层DDS层，以及聚焦通道的底层RTPS层；
* 实时性（即插即连）：提供实时特性，无论是发现，上线，下线，发送消息都能实时响应，并支持随时入网/出网；
* 同步/异步的数据发送模式；
* 可靠通信：即使在UDP通道上，也可支持可靠的通信范式；此外，也可以采用 TCP 通道；
* 传输层：UDPv4, UDPv6, TCPv4, TCPv6, SHM；
* 安全：可配置的安全通信，实现3个方面的安全配置：远程校验，访问控制，数据加密；
* 灵活性&拓展性：DDS 建立在全局数据空间的概率上，有良好的灵活性以及拓展性；
* 可移植性：通用的 RTPC 协议支持各 DDS 实现的互通，同时也支持写一遍代码运行于多个平台；
* 可配置：可以通过代码或者 XML 文件进行配置；
* 高性能：采用 FastCDR 作为序列化库；
* 统计模块
* 流量控制
* 免费开源

## 架构

> 如下图所示，FastDDS 大致可分为4层：
>
> ![](https://fast-dds.docs.eprosima.com/en/v2.6.0/_images/library_overview.svg)

1. **应用层**：提供用户友好的 API

2. **FastDDS 层**

   1. 以数据为中心的模型，虚拟出**全局数据空间**的概念，各节点向该空间声明**发布者**或者**订阅者**的意图；

     2. 抽象出 Domain 以及 Topic 的概念，不同 Domain 之间数据独立不互通，在同一个 Domain 之间通过 Topic 发布/订阅数据；

        ![](/img/posts/dds/DDS_concept.png)


3. **RTPS 层**（作为通道层的抽象）

    1. 由 OMG 联盟定义和维护，以确保不同 DDS 供应商应用程序之间可以互通；
    
    2. 基于 TCP/UDP/IP 等传输协议，提供订阅/发布通道；
    
       ![](/img/posts/dds/spec.png)

4. **通道层**

    ![](/img/posts/dds/transport_comparison.svg)

## DDS Layer

> https://fast-dds.docs.eprosima.com/en/v2.6.0/fastdds/dds_layer/dds_layer.html

#### [Qos](https://fast-dds.docs.eprosima.com/en/v2.6.0/fastdds/dds_layer/core/policy/policy.html)

它们主要可以分为下面几类：

- `durability`：定义了Writer与新Reader匹配时对于已发送的数据的行为
  1. VOLATILE（默认值）：丢掉所有已经发送的数据；
  2. TRANSIENT_LOCAL：保存最近发送的 k 条数据；
  3. TRANSIENT： 在 TRANSIENT_LOCAL 的基础上，还会持久化到磁盘；
- `liveliness`：定义Publisher的活跃程度。例如：多长时间发布一次公告消息。
- `reliability`：定义消息的可靠性。它有两个选项：
  1. `BEST_EFFORT`，发送消息时，接收者（订阅者）没有到达确认。速度快，但是消息可能会丢失。
  2. `RELIABLE`，发送方（发布者）期望接收方（订阅者）进行到达确认。速度较慢，但可以防止数据丢失。
- `partition`：可以在domain的物理分区上建立逻辑分区。
- `deadline`：指定消息的更新频率，当新消息的频率降至某个阈值以下时，会发出警报。这对于需要定期更新数据的场景很有用。
- `lifespan`：指定 Publisher 发布数据的最大有效期限。当使用寿命到期时，数据将从历史记录中删除。
- `disablePositiveAcks`：指定是否需要取消确认消息。在不需要严格可靠的通信且带宽受限时，这么做可以减少网络流量。

## RTPS Layer



## 发现协议

### 发现机制

| 发现机制     | 简介      |
| -------- | ----- |
| [Simple Discovery](https://fast-dds.docs.eprosima.com/en/v2.6.0/fastdds/discovery/simple.html) （默认） | 分为 SPDP、SEDP 两个阶段 |
| [Discovery Server](https://fast-dds.docs.eprosima.com/en/latest/fastdds/discovery/discovery_server.html#) | 集中式发现体系结构     |
| [Static Discovery](https://fast-dds.docs.eprosima.com/en/latest/fastdds/discovery/static.html) | 使用 SPDP，而 EDP 需要手工（XML）配置 |
| Manual Discovery   | 位于 RTPS 层，全手动配置 |

Discovery Server 和 Simple Discovery 的比较：

![](/img/posts/dds/discovery-server.svg)

### 发现步骤（[SIMPLE](https://fast-dds.docs.eprosima.com/en/latest/fastdds/discovery/simple.html)）

![](/img/posts/dds/discovery_wireshark.png)

1. 向指定的多播地址（默认 239.255.0.1）发送本机 DomainParticipants 信息，主要包含下图中的 DomainId,单播地址等；

   ![](/img/posts/dds/discovery_multicast.png)

   这个信息会循环发送
   1. 在 DomainParticipants 创建期间，默认以 100ms 间隔持续发送，可以通过 `discovery_config.initial_announcements.period`设置;
   2. Participants 创建完毕后，默认会以 3秒 的间隔持续发送；可通过`discovery_config.leaseDuration_announcementperiod`设置；

2. 加入多播组（239.255.0.1），以接受多播消息；

   ![](/img/posts/dds/discovery_multicast_join.png)

3. 按照 RTPS 标准，每个 Participant 需要监听 2个端口；当然，端口号可以并存预设，以及计算规则的修改；

   1. 单播端口：`unicast_port = 7400 + 250 * domainID + 10 + 2 * participantID`；
   2. 多播端口：`multicast_port = 7400 + 250 * domainId + 0`
   
   这里设计巧妙的一点，不同 domainID 使用的多播端口号是不同的，所以不同 domain 之间数据是隔离的（不会互相发现）；而且相同 domain 不同终端之间计算出来的多播端口号是一致的，所以可以直接找到对方而不用过滤；
   
4. 总体[Simple Discovery](https://fast-dds.docs.eprosima.com/en/v2.6.0/fastdds/discovery/simple.html)机制的发现步骤如下，其中多播并不是必要的，如果初始化的时候可以内置单播地址以及端口，就可以[禁用多播通道](https://fast-dds.docs.eprosima.com/en/v2.6.0/fastdds/transport/disabling_multicast.html)；

<div class="mermaid">
sequenceDiagram
	participant A as Client A
	participant G as 多播组 (239.255.0.1)
	participant B as Client B
	A->>G: 加入多播组
	B->>G: 加入多播组
	A->>A: 根据 DomainId 计算多播端口，并监听该多播端口（7400）
	B->>B: 根据 DomainId 计算多播端口（7400）
	B->>B: 根据 DomainId 计算单播端口，并监听该单播端口
	B->>G: 向多播组指定端口发送信息（包含IP地址，单播端口等）
	G->>A: 收到多播数据
	A->>A: 得到 ClientB 的IP地址以及单播端口
	A->>A: 根据 DomainId 计算单播端口，并监听该单播端口
	A->>B: 发送单播数据给 ClientB；
	B->>A: 发送单播数据，互相发现成功；
</div><!--mermaid-->


### 超时

默认 20 秒，可以通过`discovery_config.leaseDuration` 配置；

## 通道层

##### 默认通道

FastDDS 默认开启 UDP & SHM 通道，可以设置 `use_builtin_transports = false`关闭；

##### [UDP 通道](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/udp/udp.html)

```c++
DomainParticipantQos qos;

// Create a descriptor for the new transport.
auto udp_transport = std::make_shared<UDPv4TransportDescriptor>();
udp_transport->sendBufferSize = 9216;
udp_transport->receiveBufferSize = 9216;
udp_transport->non_blocking_send = true;

// Link the Transport Layer to the Participant.
qos.transport().user_transports.push_back(udp_transport);

// Avoid using the default transport
qos.transport().use_builtin_transports = false;
```

##### [TCP 通道](https://fast-dds.docs.eprosima.com/en/latest/fastdds/transport/tcp/tcp.html)

TCP 通道可以实现广域网中 DDS 的使用，区分客户端以及服务端，不同的端需要不同配置；

![](/img/posts/dds/TCP_WAN.png)

1. 服务端配置

   ```c++
   DomainParticipantQos qos;
   
   // Create a descriptor for the new transport.
   auto tcp_transport = std::make_shared<TCPv4TransportDescriptor>();
   tcp_transport->sendBufferSize = 9216;
   tcp_transport->receiveBufferSize = 9216;
   tcp_transport->add_listener_port(5100);
   tcp_transport->set_WAN_address("80.80.99.45");
   
   // Link the Transport Layer to the Participant.
   qos.transport().user_transports.push_back(tcp_transport);
   
   // Avoid using the default transport
   qos.transport().use_builtin_transports = false;
   ```

2. 客户端配置：

   ```c++
   DomainParticipantQos qos;
   
   // Disable the built-in Transport Layer.
   qos.transport().use_builtin_transports = false;
   
   // Create a descriptor for the new transport.
   // Do not configure any listener port
   auto tcp_transport = std::make_shared<TCPv4TransportDescriptor>();
   qos.transport().user_transports.push_back(tcp_transport);
   
   // Set initial peers.
   Locator_t initial_peer_locator;
   initial_peer_locator.kind = LOCATOR_KIND_TCPv4;
   IPLocator::setIPv4(initial_peer_locator, "80.80.99.45");
   initial_peer_locator.port = 5100;
   
   qos.wire_protocol().builtin.initialPeersList.push_back(initial_peer_locator);
   
   // Avoid using the default transport
   qos.transport().use_builtin_transports = false;
   ```

3. 经过测试，在同一个 Domain 中开启 TCP 以及 UDP 通道，只会有一个通道生效（前一个），这2个并不能共存；所以如果需要通过云端将多个局域网连接在一起，需要使用独立的 TCP Domain 作为隧道打通局域网；



## 安全

> FastDDS 提供5个安全构建时插件，分别是 身份鉴定，访问控制，数据加密，日志，数据标签；
>
> ![](/img/posts/dds/security.png){:width="40%"}

### 身份鉴定

在 Discovery 阶段进行，由 DomainParticipant 负责验证；

使用 CA 证书进行身份校验，并支持使用 ECDH 生成共享密钥用来做数据加密；

### 访问控制

> 对经过身份验证的域参与者能够执行的DDS相关操作强制实行各种限制

### 数据加密

### 安全日志

对上述所有的安全相关事件，全部记录下来，方便后期查看，也可以通过分析日志即使发现安全问题；

| Level                 | Definition                                     |
| --------------------- | ---------------------------------------------- |
| `EMERGENCY_LEVEL`     | System is unusable. Should not continue use.   |
| `ALERT_LEVEL`         | Should be corrected immediately.               |
| `CRITICAL_LEVEL`      | A failure in primary application.              |
| `ERROR_LEVEL`         | General error conditions. Default value.       |
| `WARNING_LEVEL`       | May indicate future error if action not taken. |
| `NOTICE_LEVEL`        | Unusual, but nor erroneous event or condition. |
| `INFORMATIONAL_LEVEL` | Normal operational. Requires no action.        |
| `DEBUG_LEVEL`         | Normal operational.                            |

### 数据标签

[数据标签](https://fast-dds.docs.eprosima.com/en/v2.6.0/fastdds/security/security.html)插件在 FastDDS 中还未实现，未来会有实现可用；

## 相关依赖

| 库                                                           | 简介                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [Asio](http://think-async.com/Asio/)                         | 用于网络和低级 I/O 编程的跨平台 C++ 库，它使用现代 C++ 方法为开发人员提供一致的异步模型。 |
| [TinyXML2](https://github.com/leethomason/tinyxml2)          | 开源、简单、小巧、高效的C++ XML解析器，它只有一个.h文件和一个.cpp文件组成。 |
| OpenSSL                                                      |                                                              |
| Foonathan memory                                             | 内存分配器                                                   |
| [Fast CDR](https://github.com/eProsima/Fast-CDR)             | FastDDS 使用的高效序列化库                                   |
| [Fast DDS-Gen ](https://fast-dds.docs.eprosima.com/en/latest/fastddsgen/introduction/introduction.html) | 一个 Java 应用程序，它根据接口描述语言 (IDL) 文件中定义的数据类型自动生成 C++ 源代码。 |

# 参考

* [DDS与FastRTPS](https://paul.pub/dds-and-fastrtps/)
* [Using DDS with TSN and Adaptive AUTOSAR](https://www.ieee802.org/1/files/public/docs2018/dg-leigh-autosar-dds-tsn-use-case-1218-v02.pdf)
* [Data Distribution Service™ (DDS™)](https://www.bilibili.com/video/BV12z4y167w2)
* [ROS 2设计文章系列之十一——ROS 2与DDS-Security的集成](https://www.guyuehome.com/37315)
* [基于安全协商的DDS安全通信中间件设计](http://netinfo-security.org/CN/Y2021/V21/I6/19)
* [工业级数据分发服务DDS简介及安全特性分析](https://blog.csdn.net/andlee/article/details/121039065)
